# HDU多校2019训练记录+题解+补题进度

[HDU 2019补题进度总览表](https://github.com/Dafenghh/Training_Summary/blob/master/HDU_train_2019%E8%A1%A5%E9%A2%98%E8%BF%9B%E5%BA%A6%E6%80%BB%E8%A7%88%E8%A1%A8.md)


## 20190723 第一场

### 总结

#### Dafeng 
今天这场的A，数组开小导致WA, 赛后10min才过。究其原因，我本来是想将第二维表示成
0,1,2的，但写的时候发现表示成1,2,3会更自然，然后就改了……但此时数组已经定义好在上面，忘了改回去……

能过A就很好了呀，明明是开场就想出来的题。

这个教训我，上机之前一定得梳理好思路。敲代码的时候，如果中途对思路进行修改，哪怕是很微小的修改，都有可能导致程序不一致。

M题敲得也有些慢，有些特殊情况没有考虑到。还敲错了一个变量名。没有1A是遗憾。

总之上机码题时，我需要保持住最清醒的状态，力求减少错误。

但今天队友发挥得不错，校内rank也比较好看。

#### Zayin
最近演的死去活来的，一上来就被D关住了，还是Dafeng比较强帮我解的围。  
然后就是快乐自（yan）闭（xi）三小时，甚至还让wcy1122去抄了份多项式全家桶，好像还是假的板子？  
后期可能清醒了一点，连着就把K，L给过了，然后B敲了一发假做法T掉了，虽然后来想到了正解但已经没有时间了...  
  
演员是我本人了，每次一到关键时候就演起来了....  

#### wcy1122
划了一下午水，除了签了道I题，帮Zayin抄了个假板子（雾）剩下啥都没做。
今天状态不是很好，很多不算太难的题都没有想出来，感谢队友带飞。

### 题解


#### A Blank  (By dafeng)

`dp[i][j][k][t]`表示前i个位置，从位置i往左看，第一个不同的位置是j，第二个不同的位置是k，第三个不同的位置是t的方案数。转移O(4).
  
  
#### B Operation [(By Zayin)](https://github.com/Dafenghh/Training_Summary/blob/master/code/HDU2019/day1/B_Zayin.cpp)
在比赛时想着往后维护线性基，但这样做的后果是不能知道线性基的大小顺序。  
所以考虑往前维护，相当于在前一个线性基集的基础上再加一个数。  
那么如果遇到一个可以替换的，肯定是把他替换掉最优（尽量往右），然后替换掉后继续往低位类似更新即可。  

时间复杂度`O(nlogw)`

#### F Typewriter (By wcy1122)
一道SAM题，之前没见过类似的模型。
枚举位置i，维护一个位置j(j<=i)，表示(j--i)的字串出现在(1--j-1)字串中。我们可以花费q的代价将(j--i)字串直接黏贴过去。
显然f[i]单调不降，所以选最长的肯定是最优的，转移方程：`f[i]=max(f[i-1]+p,f[j-1]+q)`
我们可以使用SAM来维护j。
维护(j--i-1)字串在SAM的位置pos。考虑加入s[i]，如果pos存在s[i]这个分支，说明可以直接匹配，则直接将pos转移即可。
否则，将s[j]加入SAM，并重新计算(j+1--i)字串在(1~j)字串构成的SAM中对应的位置。
如何计算？如果自动机pos位置代表的字符串的最小长度>=(i-j-1)，那么这个位置就是合法的，能够标志(j+1--i)这个字串。否则，把pos跳向它的fail，继续比较。
时间复杂度`O(n)`


#### G Meteor [(By Zayin)](https://github.com/Dafenghh/Training_Summary/blob/master/code/HDU2019/day1/G_Zayin.cpp)
一个结合了多个考点的（tao)好(lu)题.  
简短题意：将所有分子分母小于等于n的最简分数从小到大排序，问第k小是哪个分数？  
最直接的思路就是二分答案判定，但注意二分时要用分数类来二分。  
二分到精度有1/n^2就可以了，因为分母小于等于n的最简分数的两两做差最小值最小也只有1/n(n-1).  
判定小于某个值的最简分数可以直接用数论姿势化简，用数论分块+类欧判定，挺简单的就不贴出来了。  
  
最后的难点在于怎么在一个分数区间[l,r]之间找到一个分子分母小于等于n的最简分数。  
这里就要用到法雷数列/Stern-Borcot Tree的性质了，主要是其自相似的结构。  
  
我们如何在SB-Tree（滑稽）中定位一个最简分数？  
不（hen）难发现，SB—Tree的左子树如果把分母减去分子，就是和原树一模一样的，右子树则是把分子减去分母，证明利用SB-Tree的构造即可。  
那么根据这个性质，首先确定是左右子树是很简单的（判断是否小于1/1即可）,然后利用上面的自相似去掉一层继续做下去就可以定位其位置了。  

所以在一个分数区间[l,r]之间找到一个分子分母小于等于n的最简分数，等价于定位出l的位置，然后找到后面第一个分子分母小于等于n的最简分数。 
那么这题就做完了。  

