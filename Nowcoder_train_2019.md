牛客多校2019训练记录+题解

Nowcoder 2019补题进度总览表

第一场

D Parity of Tuples (By ctl)

a_{i,j} & x 全部都有奇数个1相当于\Pi(1-(-1)^{|a_{i,j} \wedge  x|}),因为后面只要有一个是偶数那么值为0

count(x)=1/(2^m)*\sum_{i=1}^n\Pi(1-(-1)^{|a_{i,j} \wedge x|}) 

\Pi(1-(-1)^{|a_{i,j} and x|}=\sum_{s}(-1)^{|x \wedge s|} 其中s是枚举所有a_{i,j}的集合

后面这个东西就是FWT的定义

可以先跑一个格雷码把s的枚举顺序搞出来然后FWT就求出count(x)了

之后就是暴力求答案了

I Points Division (By ctl)

题目中的限制：不存在i∈A，j∈B，且xi \ge xj ,yi\le yj   其实就可以把所有的点放在直角坐标系上，从上到下划一条折线，在折线左边的属于A，在折线右边的属于B

这是一个dp，考虑用线段树优化这个dp

让所有的点先属于B，对y开一棵值域线段树，所有的点按第一关键字x从小到大排序，第二关键字y从大到小排序。

对于一个点，有两种决策：①让折线向右走，让这个点i属于A，这个时候它对在它左边的点都有A[i]-B[i]的贡献。②让折线向下走，让这个点属于B，这个时候这个点可以产生的贡献是在其左边找一段最好的折线，并且需要减去之前在这个点往下走所产生的贡献。

用线段树维护区间修改和区间最值



第二场

J Subarray (By dafeng)

先考虑假如数组长度只有1e7，我们是否能有线性做法呢？

对于右端点r，假如它的前缀和为x，那么以r为右端点的答案区间个数就等于r左边小于x的前缀和个数。

我们用tot[x]表示当前统计到的前缀和小于x的出现次数。

如果用个deque维护， 那么前缀和x就相当于一个在deque上来回移动的指针，并且每次只移动一个单位。如果我们扫到了右端点r，前缀和为x，并且求得tot[x], 那么就将这个tot[x]更新到答案。然后，我们还需要将tot[i], i > x 全部加一，这个维护个增量数组f[x]就可以O(1)更新了。当x往右移动时就传递增量f[x]，往左移动不用传递。

题目是1e9的数组，但只有1e7个1. 于是中间会有很多-1. 我们就在这里判一下，如果-1太多，使得后面的点不会以现在已扫过的点作为左端点，就直接跳过这些-1.

具体来说，设[Li,Ri]是第i段1， 我们先预处理出以Li为左端点的最大的区间和。假如我们现在处于位置p, 位于[R_(i-1), Li]这段-1区间, 并且刚刚得到了一个最小的前缀和(1..p的前缀和是目前求得的最小的前缀和，也就是以p为右端点，没有一个区间的和大于零)，如果以p+1为左端点的任何一个区间和都不大于零， 我们就认为p之前的值不会对后面的答案产生贡献了。于是跳过若干个-1，并且将deque清空重来。








