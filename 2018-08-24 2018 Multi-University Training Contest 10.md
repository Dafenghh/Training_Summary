# 2018 Multi-University Training Contest 10
Date: 2018-08-24

## Practice Link
https://vjudge.net/contest/248150

## 流水账
开场，赛波过了高精度签到题H。之后达烽做G(容斥)，立辉做L(费用流)。立辉L抄完模板后WA了。达烽推错了公式，卡了很久很久，到2h30min才过了G。之后立辉发现I是水题，达烽发现J是水题，数分钟后连过两道。之后立辉敲了一发暴力构图，过了L。3h57min立辉过了E。随后赛波和立辉想C，达烽想D。都没搞出来。
## 个人总结
### 徐达烽
今天这场就打得很糟糕了，首先签到性质的G搞了这么久，实在不应该。另外大水题J应该早点发现早点过的。（Claris所说读新题优先级高于一切）D的DP差最后一步就想出正解了，超伤心的。

### 梁赛波
今天写了个签到之后就没什么贡献了，感觉这几天的训练我都在梦游啊，这个D如果放在2个月之前感觉非常可搞，现在完全没办法想到关键的点，真的感觉现在水平比几个月前差到不知道哪里去了，跟队友讨论题目的时候也有点迷，脑子有点静止。最近一直不是十分振奋，可能我不是很适合这种持续的训练，可能开学之后要好好继续刷一下TC找一下状态了。

### 谢立辉
开场时是我和赛波想的L，一开始以为是DP想好久，然后听到后排在讨论费用流什么的，哎呀这不傻逼费用流嘛。。。看来是最近网络流做的太少了。。。然后我想到的是暴力构图，赛波给了一个很优美的建图，我权衡一下后打了赛波那个版本的，结果WA了几发，到现在还是不懂哪错了。。。然后就弃掉了L去想I，转化了一下公式后发现原来这是签到题。。。5分钟打完马上就A了。有了I的鼓励我就继续和L杠，结果肉眼查错si都查不出，然后赛波就想不如打一发暴力构图好了，我本想会T的，结果竟然A了。。。超级无语，还是62ms过的。。。去厕所时碰到了室友，他们队在写E但是WA了几发，然后他问我欧拉序列求LCA的问题，我跟他说了之后他发现是他写错了。回来后队友也在想E，计划是写启发式合并的，但是复杂度可能被卡，然后我的室友跑过来跟我说他们队A了，然后为了感激我把他的做法告诉了我23333，然后就顺利切掉了E。切完还剩1小时左右，我就和赛波一起去想C，写完式子哎呀这不傻逼反演吗，然后事实是我推错了式子orz，然后比赛就结束了。。。今天的题好像都很可做，然后都是半知半懂的状态，都是经别人提醒才会做的，感觉基础不太扎实啊，以后还是得巩固一下基础。

## 要补的题+题解
### D题
很好的一道DP题。对一个排列a,设它与标准排列的曼哈顿距离为s，对所有s,求排列数。

 |1|2|3|4|
 |-|-|-|-|
 |?|?|?|?|
 
 我们在第二行填入1..n。填完之后，把绝对值拆开，每一列的数一正一负，例如：
 
 |-1|-2|+3|+4|
 |--|--|--|--|
 |+2|+4|-3|-1|
 
 事实上，只需要知道取负的数（即同一列中较小的数）的和，就能算得全部的和。
 
 再发现，第二行中，对任意一个数x，当它在前x列则取正，否则取负。
 
 `f[i][j][s]`表示前i列中，有j个空白位置（未填），取负的数的和为s的方案数。其实1..i中，没有用过的数也是j个。
根据a[i]填什么数，i放哪个位置来讨论，从而写出转移。
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 105;
int f[2][N][N*N], r[2][N], ans[N*N];
int n,Mod;
void add(int &a, ll b) {
    a = (a + b) % Mod;
}
void init(int i) {
    int now = i & 1;
    for (int j = 0; j <= i; j++) {
        for (int s = 0; s <= r[now][j]; s++) 
            f[now][j][s] = 0;
        r[now][j] = 0;
    }
}
void Maxi(int &a, int b) {
    if (b > a) a = b;
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &Mod);      
        memset(f,0,sizeof f);
        memset(r,0,sizeof r);
        f[0][0][0] = 1;
        for (int i = 0; i < n; i++) {
            int now = i & 1;
            int x = i + 1;
            init(i+1);
            for (int j = 0; j <= i; j++)
            for (int s = 0; s <= r[now][j]; s++) {
                if (f[now][j][s] == 0) continue;
                add(f[now^1][j][s+x], (1LL + 2 * j)*f[now][j][s]);
                Maxi(r[now^1][j], s + x);
                add(f[now^1][j+1][s+2*x], f[now][j][s]);
                Maxi(r[now^1][j+1], s + 2 * x);
                if (j > 0) {
                    add(f[now^1][j-1][s], 1LL*j*j*f[now][j][s]);
                    Maxi(r[now^1][j-1],s);
                }
            }                
        }
        for (int s = 0; s <= n * (n + 1) / 2; s++)
            ans[n*(n+1) - 2 * s] = f[n&1][0][s];
        for (int i = 0; i < n * n; i++)
            printf("%d%c", ans[i], " \n"[i==n*n-1]);
    }
}
```
 
### C题
待补
### K题
发现是好简单的DP。
考虑第i位，如果目标数是0，那直接跳过考虑下一位；如果目标数是1，这时候可以选择填进该位一个正的1，也可以填一个负的1，填正的1直接往下做就行了，填负的1，则相当于对下一位产生一个进位。

那么dp[i][0]表示第i位不产生进位的答案，dp[i][1]表示第i位产生进位的答案。

再预处理一下，产生第i位的±1需要的数字个数的最小值。这题就很轻松愉快地做完了~
```c++
#include <bits/stdc++.h>
using namespace std;
int n;
const int N = 1e5+10;
const int INF = 1e9+1;
char s[N], cs[2][N];
void Mini(int &a, int b) {
    if (b < a) a = b;
}
int c[N][2], dp[N][2];
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        scanf("%s%s%s", s, cs[0], cs[1]);
        ++n;
        for (int j = 0; j < 2; j++)
        for (int i = 0; i < n; i++) {
            c[i][j] = INF;
            if (cs[j][i] != '1') Mini(c[i][j], 1);
            if (i > 0) Mini(c[i][j], c[i-1][j] * 2);
        }      
        dp[n][0] = 0;
        dp[n][1] = INF;
        for (int i = n - 1; i >= 0; i--) {
            dp[i][0] = dp[i][1] = INF;
            if (s[i] == '1') {
                Mini(dp[i][0], c[i][0]+dp[i+1][0]);
                Mini(dp[i][0], c[i][1]+dp[i+1][1]);
                Mini(dp[i][1], dp[i+1][1]);
            }
            else {
                Mini(dp[i][1], c[i][0]+dp[i+1][0]);
                Mini(dp[i][1], c[i][1]+dp[i+1][1]);
                Mini(dp[i][0], dp[i+1][0]);
            }
        }
        printf("%d\n", dp[0][0]); 
    }
}
```

### A题

