# Ural Championship 2011
Date: 2018-10-04

## Practice Link
https://vjudge.net/contest/257653

## 流水账
国庆集训。开场，立辉敲H，WA了两发。达烽提醒了一个坑点，立辉改了后就过了。然后赛波敲I，也WA了两发，1h11min AC. 立辉敲A (DP), WA了两发，1LL的细节，1h44min AC。然后达烽交了两发假的C，立辉敲了个纯暴力过了(3h4min)。接着立辉和赛波敲G，4h33min过了。达烽敲B，概率DP，一直过不了样例，原来是读错题了……

## 个人总结
### 徐达烽
今天状态极差(可能是国庆放了个假？)，读题感觉很费劲，想题脑子转不动。 C贡献假算法，B还读错题了。明天集训要做好些……
### 谢立辉
今天感觉做不动题了。。。读题不是很想读，如果可以帮队友读些题，可能会好一点？开场时敲代码不是很专心，敲着敲着就忘了要干嘛，导致一堆bug，后场状态好了一点，起码扳回了一题。。。

## 要补的题+题解
### B
其实答案就是每位加法的基本代价（1）+写下每一位答案的代价（1）+加数超过1的加法的代价（1）+进位的代价（1）。
前两个的答案显然是2k，加数超过1的考虑每一对数的补集，把没出现过的情况减掉就是出现过至少一次的情况，进位的情况直接数位dp。
```c++
#include<bits/stdc++.h>
#define maxn 5005
using namespace std;
typedef long long LL;

int n;

double dp[maxn][2];

void init()
{
	scanf("%d",&n);
}

void solve()
{
	double ans=2*n,p1=1.0,p2=1.0;
	
	dp[0][0]=1;
	for (int i=1;i<n;++i)
	{
		dp[i][0]=0.55*dp[i-1][0]+0.45*dp[i-1][1];
		dp[i][1]=0.45*dp[i-1][0]+0.55*dp[i-1][1];
		ans+=dp[i][1]*2;
		p1*=0.98;
		p2*=0.99;
	}
	
	p1*=79.0/81.0;
	p2*=80.0/81.0;
	
	ans+=(1.0-p1)*28.0+(1.0-p2)*8;
	
	dp[n][1]=45.0/81.0*dp[n-1][0]+53.0/81.0*dp[n-1][1];
	
	ans+=dp[n][1]*2;
	
	printf("%.10lf\n",ans);
}

int main()
{
    init();
    solve();
    return 0;
}
```
### D
### F
### J
### K


